include "stdio.h"
include "stdlib.h"
include "string.h"
include "fcntl.h"
%if darwin
include "sys/event.h"
%else
include "sys/epoll.h"
%end
include "errno.h"
include "three/c11/threads.h"
include "three/runtime/closure.h" # this should not be necessary

namespace Core::Event

  public
  enum Type
    Read
    Write
  end

  struct Monitor
    thrd_t thread
%if darwin
    Int kq
%else
    Int efd
%end
    *{Natural descriptor, Natural data} closure_ptr
  end

  private
%if darwin
  def event_thread_entry(*Void arg; Int)
    *Monitor monitor = arg
    kevent64_s ke

    loop
      memset(&ke, 0, sizeof(kevent64_s))

      Int result = kevent64(monitor->kq, null, 0, &ke, 1, 0, null)

      # EV_EOF 0x8000
      if ke.data == 0 && ke.flags & 0x8000
        # TODO: It is completely wrong for this thread to exit
        printf("ERROR: kqueue thread exiting\n")
        return 1
      end

      printf("woke for data: %lld flags: %x\n", ke.data, ke.flags)

      if monitor->closure_ptr
        (*monitor->closure_ptr)(ke.ident, ke.data)
      end
    end

    return 0
  end
%else
  def event_thread_entry(*Void arg; Int)
    *Monitor monitor = arg
    epoll_event event

    loop
      memset(&event, 0, sizeof(epoll_event))

      Int numberFds = epoll_wait(monitor->efd, &event, 1, -1)

      if numberFds != 1
        printf("ERROR: epoll_wait thread exiting\n")
        return 1
      end

      printf("woke for event: %x \n", event.events)

      if monitor->closure_ptr
        #(*monitor->closure_ptr)(event.data.fd, ke.data)
      end
    end

    return 0
  end
%end

  public
  def monitor_create(; *Monitor)
    *Monitor monitor

    monitor = malloc(sizeof(Monitor))
%if darwin
    monitor->kq = kqueue()
%else
    # The zero means we do not need epoll's FD_CLOEXEC feature
    monitor->efd = epoll_create1(0)
%end
    monitor->closure_ptr = null

    thrd_create(&monitor->thread, Core::Event::event_thread_entry, monitor)

    return monitor
  end

  def prepare_descriptor(Natural descriptor)
%if darwin
    # F_SETFL 4
    # O_NONBLOCK 0x0004
    if fcntl(descriptor, 4, 0x0004) == -1
%else
    # for ubuntu
    # F_SETFL 4
    # O_NONBLOCK 04000 => 0x800
    if fcntl(descriptor, 4, 0x800) == -1
%end
      printf("Unable to make descriptor non-blocking\n")
    end
  end

  def Monitor.watch(Type type, Natural descriptor, {Natural descriptor, Natural data} closure; Natural)
%if darwin
    kevent64_s ke

    memset(&ke, 0, sizeof(kevent64_s))

    ke.ident = descriptor
    switch type
    case Core::Event::Type::Read
      Core::Event::prepare_descriptor(descriptor)
      ke.filter = -1 # EVFILT_READ
      ke.flags = 0x0001 | 0x0004 # EV_ADD | EV_ENABLE
    case Core::Event::Type::Write
      Core::Event::prepare_descriptor(descriptor)
      ke.filter = -2 # EVFILT_WRITE
      ke.flags = 0x0001 | 0x0004 # EV_ADD | EV_ENABLE
    end

    if kevent64(self->kq, &ke, 1, null, 0, 0, null) == -1
      printf("Unable to arm the event %d\n", (*__error()))
      return 0
    end
%else
    epoll_event event

    memset(&event, 0, sizeof(epoll_event))

    # something is broken here...
    # event.data.fd = descriptor
    switch type
    case Core::Event::Type::Read
      Core::Event::prepare_descriptor(descriptor)
      event.events = 0x001 # EPOLLIN
    case Core::Event::Type::Write
      Core::Event::prepare_descriptor(descriptor)
      event.events = 0x004 # EPOLLOUT
    end

    # EPOLL_CTL_ADD 1
    if epoll_ctl(self->efd, 1, descriptor, &event) == -1
      printf("Unable to arm the event %d\n", (*__errno_location()))
      return 0
    end
%end

    # TODO: this is definitely not right.  We need to store these closures
    # per-type and per-descriptor
    printf("making a copy for monitor\n")
    self->closure_ptr = three_closure_copy(closure)

    return 1
  end

  def Monitor.unwatch(Natural registration_ticket)
  end

end
